// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: runs.sql

package db

import (
	"context"
	"database/sql"
)

const createRun = `-- name: CreateRun :one
INSERT INTO runs (name, title, description, docker_image, parameters, data, mounts, created_at)
VALUES (?,?,?,?,?,?,?,date('now'))
RETURNING id, name, title, description, docker_image, mounts, parameters, data, created_at, started_at, finished_at, status, has_errored, error_message
`

type CreateRunParams struct {
	Name        string `json:"name"`
	Title       string `json:"title"`
	Description string `json:"description"`
	DockerImage string `json:"dockerImage"`
	Parameters  string `json:"parameters"`
	Data        string `json:"data"`
	Mounts      string `json:"mounts"`
}

func (q *Queries) CreateRun(ctx context.Context, arg CreateRunParams) (Run, error) {
	row := q.db.QueryRowContext(ctx, createRun,
		arg.Name,
		arg.Title,
		arg.Description,
		arg.DockerImage,
		arg.Parameters,
		arg.Data,
		arg.Mounts,
	)
	var i Run
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.DockerImage,
		&i.Mounts,
		&i.Parameters,
		&i.Data,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.HasErrored,
		&i.ErrorMessage,
	)
	return i, err
}

const finishRun = `-- name: FinishRun :one
UPDATE runs SET status = 'finished', finished_at = date('now')
WHERE id = ?
RETURNING id, name, title, description, docker_image, mounts, parameters, data, created_at, started_at, finished_at, status, has_errored, error_message
`

func (q *Queries) FinishRun(ctx context.Context, id int64) (Run, error) {
	row := q.db.QueryRowContext(ctx, finishRun, id)
	var i Run
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.DockerImage,
		&i.Mounts,
		&i.Parameters,
		&i.Data,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.HasErrored,
		&i.ErrorMessage,
	)
	return i, err
}

const getAllRuns = `-- name: GetAllRuns :many
SELECT id, name, title, description, docker_image, mounts, parameters, data, created_at, started_at, finished_at, status, has_errored, error_message FROM runs
`

func (q *Queries) GetAllRuns(ctx context.Context) ([]Run, error) {
	rows, err := q.db.QueryContext(ctx, getAllRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.DockerImage,
			&i.Mounts,
			&i.Parameters,
			&i.Data,
			&i.CreatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Status,
			&i.HasErrored,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getErroredRuns = `-- name: GetErroredRuns :many
SELECT id, name, title, description, docker_image, mounts, parameters, data, created_at, started_at, finished_at, status, has_errored, error_message FROM runs WHERE status = 'errored'
`

func (q *Queries) GetErroredRuns(ctx context.Context) ([]Run, error) {
	rows, err := q.db.QueryContext(ctx, getErroredRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.DockerImage,
			&i.Mounts,
			&i.Parameters,
			&i.Data,
			&i.CreatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Status,
			&i.HasErrored,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFinishedRuns = `-- name: GetFinishedRuns :many
SELECT id, name, title, description, docker_image, mounts, parameters, data, created_at, started_at, finished_at, status, has_errored, error_message FROM runs WHERE status = 'finished'
`

func (q *Queries) GetFinishedRuns(ctx context.Context) ([]Run, error) {
	rows, err := q.db.QueryContext(ctx, getFinishedRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.DockerImage,
			&i.Mounts,
			&i.Parameters,
			&i.Data,
			&i.CreatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Status,
			&i.HasErrored,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIdleRuns = `-- name: GetIdleRuns :many
SELECT id, name, title, description, docker_image, mounts, parameters, data, created_at, started_at, finished_at, status, has_errored, error_message FROM runs WHERE status = 'pending'
`

func (q *Queries) GetIdleRuns(ctx context.Context) ([]Run, error) {
	rows, err := q.db.QueryContext(ctx, getIdleRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.DockerImage,
			&i.Mounts,
			&i.Parameters,
			&i.Data,
			&i.CreatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Status,
			&i.HasErrored,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRun = `-- name: GetRun :one
SELECT id, name, title, description, docker_image, mounts, parameters, data, created_at, started_at, finished_at, status, has_errored, error_message FROM runs WHERE id = ?
`

func (q *Queries) GetRun(ctx context.Context, id int64) (Run, error) {
	row := q.db.QueryRowContext(ctx, getRun, id)
	var i Run
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.DockerImage,
		&i.Mounts,
		&i.Parameters,
		&i.Data,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.HasErrored,
		&i.ErrorMessage,
	)
	return i, err
}

const getRunning = `-- name: GetRunning :many
SELECT id, name, title, description, docker_image, mounts, parameters, data, created_at, started_at, finished_at, status, has_errored, error_message FROM runs WHERE status = 'running'
`

func (q *Queries) GetRunning(ctx context.Context) ([]Run, error) {
	rows, err := q.db.QueryContext(ctx, getRunning)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Run
	for rows.Next() {
		var i Run
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Title,
			&i.Description,
			&i.DockerImage,
			&i.Mounts,
			&i.Parameters,
			&i.Data,
			&i.CreatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Status,
			&i.HasErrored,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const runErrored = `-- name: RunErrored :one
UPDATE runs SET status = 'errored', error_message = ?, finished_at = date('now'), has_errored = TRUE
WHERE id = ?
RETURNING id, name, title, description, docker_image, mounts, parameters, data, created_at, started_at, finished_at, status, has_errored, error_message
`

type RunErroredParams struct {
	ErrorMessage sql.NullString `json:"errorMessage"`
	ID           int64          `json:"id"`
}

func (q *Queries) RunErrored(ctx context.Context, arg RunErroredParams) (Run, error) {
	row := q.db.QueryRowContext(ctx, runErrored, arg.ErrorMessage, arg.ID)
	var i Run
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.DockerImage,
		&i.Mounts,
		&i.Parameters,
		&i.Data,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.HasErrored,
		&i.ErrorMessage,
	)
	return i, err
}

const startRun = `-- name: StartRun :one
UPDATE runs SET status = 'running', started_at = date('now')
WHERE id = ?
RETURNING id, name, title, description, docker_image, mounts, parameters, data, created_at, started_at, finished_at, status, has_errored, error_message
`

func (q *Queries) StartRun(ctx context.Context, id int64) (Run, error) {
	row := q.db.QueryRowContext(ctx, startRun, id)
	var i Run
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Title,
		&i.Description,
		&i.DockerImage,
		&i.Mounts,
		&i.Parameters,
		&i.Data,
		&i.CreatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.HasErrored,
		&i.ErrorMessage,
	)
	return i, err
}
